## IO模型

### 一、IO模型分类

IO模型就是说用什么样的通道进行数据的发送和接收，Java共支持3种网络编程IO模式：**BIO，NIO，AIO** 

##### 1. BIO-Blocking IO

同步阻塞模型，一个客户端连接对应一个处理线程

![1615537522647](img/1615537522647.png)

- 缺点

  1、IO代码里read操作是阻塞操作，如果连接不做数据读写操作会导致线程阻塞，浪费资源 

  2、如果线程很多，会导致服务器线程太多，压力太大。

- 应用

  适用于连接数目较小且固定的架构，对服务器要求高，但编码简单

  

##### 2. NIO-Non Blocking IO

同步非阻塞，服务器实现模式为一个线程可以处理多个请求(连接)，客户端发送的连接请求都会注册到**多路复用器selector**上，多路复用器轮询到连接有IO请求就进行处理。 

![1615537950322](img/1615537950322.png)

- I/O多路复用底层实现：Linux API（select，poll，epoll）来实现，区别： 

![1615537775227](img/1615537775227.png)

- 适用

  NIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂， JDK1.4 开始支持

三大核心组件： **Channel(通道)， Buffer(缓冲区)，Selector(选择器)** 

![1615538035905](img/1615538035905.png)

> 1、channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组 
>
> 2、channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理 
>
> 3、selector 可以对应一个或多个线程 
>
> 4、NIO 的 Buffer 和 channel 都是既可以读也可以写 

NIO服务端程序详解：

> 1、创建一个 ServerSocketChannel 和 Selector ，并将 ServerSocketChannel 注册到 Selector 上 
>
> 2、 selector 通过 select() 方法监听 channel 事件，当客户端连接时，selector 监听到连接事件， 获取到 ServerSocketChannel 注册时绑定的 selectionKey 
>
> 3、selectionKey 通过 channel() 方法可以获取绑定的 ServerSocketChannel 
>
> 4、ServerSocketChannel 通过 accept() 方法得到 SocketChannel 
>
> 5、将 SocketChannel 注册到 Selector 上，关心 read 事件 
>
> 6、注册后返回一个 SelectionKey, 会和该 SocketChannel 关联 
>
> 7、selector 继续通过 select() 方法监听事件，当客户端发送数据给服务端，selector 监听到read事件，获取到 SocketChannel 注册时绑定的 selectionKey 
>
> 8、selectionKey 通过 channel() 方法可以获取绑定的 socketChannel 
>
> 9、将 socketChannel 里的数据读取出来 
>
> 10、用 socketChannel 将服务端数据写回客户端 
>
> **总结：**NIO模型的selector 就像一个大总管，负责监听各种IO事件，然后转交给后端线程去处理 **NIO相对于BIO非阻塞的体现就在，BIO的后端线程需要阻塞等待客户端写数据(比如read方法)，如果客户端不写数据线程就要阻塞，** **NIO把等待客户端操作的事情交给了大总管 selector，selector 负责轮询所有已注册的客户端，发现有事件发生了才转交给后端线程处** **理，后端线程不需要做任何阻塞等待，直接处理客户端事件的数据即可，处理完马上结束，或返回线程池供其他客户端事件继续使用。还** **有就是 channel 的读写是非阻塞的。** **Redis就是典型的NIO线程模型**，selector收集所有连接的事件并且转交给后端线程，线程连续执行所有事件命令并将结果写回客户端

![1615538269041](img/1615538269041.png)

##### 3. AIO 

异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用 （重操作），JDK7 开始支持 



##### 4. 三种IO的对比

![1615538423146](img/1615538423146.png)

> 老张爱喝茶，废话不说，煮开水。 
>
> 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 
>
> 1 老张把水壶放到火上，立等水开。**（同步阻塞）** 
>
> 老张觉得自己有点傻 
>
> 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。**（同步非阻塞）** 
>
> 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 
>
> 3 老张把响水壶放到火上，立等水开。**（异步阻塞）** 
>
> 老张觉得这样傻等意义不大 
>
> 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。**（异步非阻塞）** 
>
> 老张觉得自己聪明了。 
>
> 所谓同步异步，只是对于水壶而言。 
>
> 普通水壶，同步；响水壶，异步。 
>
> 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 
>
> 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 
>
> 所谓阻塞非阻塞，仅仅对于老张而言。 
>
> 立等的老张，阻塞；看电视的老张，非阻塞。





























